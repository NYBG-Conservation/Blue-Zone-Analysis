"""
Blue Zone Analysis â€” MERGE (combine past/present/future union CSVs)

Purpose
-------
Merge the three per-era union CSVs on `unique_id` and compute a consolidated `BZ` flag where
all three (past, present, future) equal 1.

Path Configuration
------------------
Paths are configurable via environment variables (see list below). Sensible project-relative defaults
match the outputs generated by the other generalized scripts.

Environment variables (optional)
--------------------------------
  # Inputs (override as needed)
  PAST_UNION_CSV      -> path to past_union.csv (default: output_csv/past/past_union.csv)
  PRESENT_UNION_CSV   -> path to present_union.csv (default: output_csv/present/present_union.csv)
  FUTURE_UNION_CSV    -> path to future_union.csv (default: output_csv/future/future_union.csv)

  # Output (either specify file directly or override directory)
  MERGED_OUTPUT_CSV   -> final merged CSV path (default: <BLUEZONES_OUTPUT_DIR or ./output_csv>/merged/BZ_criteria_all.csv)
  BLUEZONES_OUTPUT_DIR-> optional root for outputs (used only if MERGED_OUTPUT_CSV is not set)
"""
from __future__ import annotations
import os
from pathlib import Path
import pandas as pd

# -------- helpers (inline to avoid hard dependency on common_paths) ---------

def _base_dir() -> Path:
    return Path(os.getenv("BLUEZONES_BASE_DIR", ".")).resolve()


def _default_output_root() -> Path:
    root = os.getenv("BLUEZONES_OUTPUT_DIR")
    return Path(root) if root else _base_dir() / "output_csv"


def _path_from_env(env_var: str, relative_default: str) -> Path:
    return Path(os.getenv(env_var, str(_base_dir() / relative_default)))

# ------------------------- configure inputs/outputs -------------------------
PAST_UNION   = _path_from_env("PAST_UNION_CSV",    "output_csv/past/past_union.csv")
PRESENT_UNION= _path_from_env("PRESENT_UNION_CSV", "output_csv/present/present_union.csv")
FUTURE_UNION = _path_from_env("FUTURE_UNION_CSV",  "output_csv/future/future_union.csv")

merged_out_env = os.getenv("MERGED_OUTPUT_CSV")
if merged_out_env:
    MERGED_OUT = Path(merged_out_env)
    MERGED_OUT.parent.mkdir(parents=True, exist_ok=True)
else:
    MERGED_OUT_DIR = _default_output_root() / "merged"
    MERGED_OUT_DIR.mkdir(parents=True, exist_ok=True)
    MERGED_OUT = MERGED_OUT_DIR / "BZ_criteria_all.csv"

# ------------------------------ load inputs --------------------------------
# Use low_memory=False for wide CSVs; coerce types after read for safety
cols_needed = ["unique_id", "BZ_past", "BZ_present", "BZ_future"]

# Load each CSV (they may contain many more columns)
df_past = pd.read_csv(PAST_UNION, low_memory=False)
df_pres = pd.read_csv(PRESENT_UNION, low_memory=False)
df_futr = pd.read_csv(FUTURE_UNION, low_memory=False)

# Ensure unique_id is numeric but keep as int for merging consistency
for d in (df_past, df_pres, df_futr):
    if d["unique_id"].dtype.kind in {"O", "U"}:
        d["unique_id"] = pd.to_numeric(d["unique_id"], errors="coerce")
    d["unique_id"] = d["unique_id"].astype("Int64")

# ------------------------------- merge -------------------------------------
merged = df_past.merge(df_pres, on="unique_id", how="inner", suffixes=("_past", "_pres"))
merged = merged.merge(df_futr, on="unique_id", how="inner")

# If columns exist with duplicates due to suffixing, prefer a clean set
keep = ["unique_id"]
for c in ["BZ_past", "BZ_present", "BZ_future"]:
    # Select column if present; otherwise try suffixed variants
    if c in merged.columns:
        keep.append(c)
    else:
        # fallback for potential suffix collisions
        candidates = [x for x in merged.columns if x.startswith(c + "_")]
        if candidates:
            keep.append(candidates[0])

merged = merged[keep]

# Normalize column names back to canonical
rename_map = {}
for c in merged.columns:
    if c.startswith("BZ_past_"):
        rename_map[c] = "BZ_past"
    elif c.startswith("BZ_present_"):
        rename_map[c] = "BZ_present"
    elif c.startswith("BZ_future_"):
        rename_map[c] = "BZ_future"
merged = merged.rename(columns=rename_map)

# ------------------------------- flags -------------------------------------
# Ensure numeric
for c in ["BZ_past", "BZ_present", "BZ_future"]:
    if c in merged.columns:
        merged[c] = pd.to_numeric(merged[c], errors="coerce").fillna(0).astype(int)

merged["BZ"] = 0
condition = (
    (merged.get("BZ_present", 0) == 1) &
    (merged.get("BZ_past", 0) == 1) &
    (merged.get("BZ_future", 0) == 1)
)
merged.loc[condition, "BZ"] = 1

# ------------------------------- save --------------------------------------
merged.to_csv(MERGED_OUT, index=False)
print(f"Merged CSV written: {MERGED_OUT}")
